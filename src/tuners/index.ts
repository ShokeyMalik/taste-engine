/**
 * Recipe Depth Controls (Tuners)
 *
 * Tunable knobs that change output substantially without new code.
 * Same theme pack can feel like 5 different "tastes" based on tuner values.
 *
 * The 5 tuners:
 * - abstraction: motif intensity, signal complexity, background layers
 * - density: gaps, maxWidth, table density, surface padding
 * - motion: path draw, card expansion, hover glow
 * - contrast: border opacity, text muted levels
 * - narrative: section spacing, hero height, ribbon prominence
 *
 * @version 1.0.0
 */

import type { TunerValues, AppliedTuners } from '../mcp/contract';

// =============================================================================
// TYPES
// =============================================================================

/**
 * CSS variable overrides generated by tuners
 */
export interface TunerCSSOverrides {
  /** CSS variable name -> value */
  [key: string]: string;
}

/**
 * Recipe overrides generated by tuners
 */
export interface TunerRecipeOverrides {
  /** Motif intensity override */
  motifIntensity?: number;

  /** Signal path complexity */
  signalComplexity?: 'simple' | 'medium' | 'complex';

  /** Background layer count */
  backgroundLayers?: number;

  /** Section gap multiplier */
  sectionGapMultiplier?: number;

  /** Hero height multiplier */
  heroHeightMultiplier?: number;

  /** Ribbon prominence */
  ribbonProminence?: 'subtle' | 'normal' | 'prominent';

  /** Path draw animation enabled */
  pathDrawEnabled?: boolean;

  /** Card expansion enabled */
  cardExpansionEnabled?: boolean;

  /** Hover glow enabled */
  hoverGlowEnabled?: boolean;

  /** Surface padding scale */
  surfacePaddingScale?: number;

  /** Table density */
  tableDensity?: 'compact' | 'normal' | 'spacious';

  /** Max content width */
  maxContentWidth?: string;
}

/**
 * Complete tuner output
 */
export interface TunerOutput {
  /** Applied tuner values (normalized 0-1) */
  tuners: AppliedTuners;

  /** CSS variable overrides */
  cssOverrides: TunerCSSOverrides;

  /** Recipe overrides */
  recipeOverrides: TunerRecipeOverrides;

  /** Human-readable description of the tuning */
  description: string;
}

// =============================================================================
// DEFAULT VALUES
// =============================================================================

/**
 * Default tuner values (neutral position)
 */
export const DEFAULT_TUNERS: AppliedTuners = {
  abstraction: 0.5,
  density: 0.5,
  motion: 0.5,
  contrast: 0.5,
  narrative: 0.5,
};

/**
 * Tuner value bounds
 */
export const TUNER_BOUNDS = {
  min: 0,
  max: 1,
  step: 0.1,
} as const;

// =============================================================================
// TUNER APPLICATION
// =============================================================================

/**
 * Normalize tuner values (clamp to 0-1)
 */
export function normalizeTuners(input: Partial<TunerValues>): AppliedTuners {
  const clamp = (v: number | undefined, def: number) =>
    v !== undefined ? Math.max(0, Math.min(1, v)) : def;

  return {
    abstraction: clamp(input.abstraction, DEFAULT_TUNERS.abstraction),
    density: clamp(input.density, DEFAULT_TUNERS.density),
    motion: clamp(input.motion, DEFAULT_TUNERS.motion),
    contrast: clamp(input.contrast, DEFAULT_TUNERS.contrast),
    narrative: clamp(input.narrative, DEFAULT_TUNERS.narrative),
  };
}

/**
 * Generate CSS variable overrides from tuner values
 */
export function generateCSSOverrides(tuners: AppliedTuners): TunerCSSOverrides {
  const overrides: TunerCSSOverrides = {};

  // Density -> spacing and padding
  const densityScale = 0.6 + tuners.density * 0.8; // 0.6 to 1.4
  overrides['--tuner-spacing-scale'] = densityScale.toFixed(2);
  overrides['--tuner-gap-base'] = `${Math.round(24 * (1.5 - tuners.density))}px`; // 12-36px
  overrides['--tuner-padding-surface'] = `${Math.round(16 * (1.5 - tuners.density * 0.5))}px`; // 12-24px

  // Contrast -> border and text opacity
  const borderOpacity = 0.05 + tuners.contrast * 0.15; // 0.05 to 0.2
  const textMutedOpacity = 0.4 + tuners.contrast * 0.3; // 0.4 to 0.7
  overrides['--tuner-border-opacity'] = borderOpacity.toFixed(2);
  overrides['--tuner-text-muted-opacity'] = textMutedOpacity.toFixed(2);

  // Narrative -> section spacing and heights
  const sectionGap = 80 + tuners.narrative * 80; // 80-160px
  const heroHeight = 70 + tuners.narrative * 30; // 70-100vh
  overrides['--tuner-section-gap'] = `${Math.round(sectionGap)}px`;
  overrides['--tuner-hero-min-height'] = `${Math.round(heroHeight)}vh`;

  // Abstraction -> motif opacity and blur
  const motifOpacity = 0.02 + tuners.abstraction * 0.18; // 0.02 to 0.2
  const motifBlur = Math.round(tuners.abstraction * 8); // 0 to 8px
  overrides['--tuner-motif-opacity'] = motifOpacity.toFixed(2);
  overrides['--tuner-motif-blur'] = `${motifBlur}px`;

  // Motion -> transition durations and animation
  const transitionBase = 150 + tuners.motion * 350; // 150-500ms
  overrides['--tuner-transition-fast'] = `${Math.round(transitionBase * 0.5)}ms`;
  overrides['--tuner-transition-base'] = `${Math.round(transitionBase)}ms`;
  overrides['--tuner-transition-slow'] = `${Math.round(transitionBase * 2)}ms`;

  return overrides;
}

/**
 * Generate recipe overrides from tuner values
 */
export function generateRecipeOverrides(tuners: AppliedTuners): TunerRecipeOverrides {
  const overrides: TunerRecipeOverrides = {};

  // Abstraction
  overrides.motifIntensity = tuners.abstraction;
  overrides.signalComplexity = tuners.abstraction < 0.3 ? 'simple' :
                               tuners.abstraction > 0.7 ? 'complex' : 'medium';
  overrides.backgroundLayers = Math.round(1 + tuners.abstraction * 3); // 1-4 layers

  // Density
  overrides.surfacePaddingScale = 0.6 + (1 - tuners.density) * 0.8; // Inverse: low density = more padding
  overrides.tableDensity = tuners.density < 0.3 ? 'spacious' :
                           tuners.density > 0.7 ? 'compact' : 'normal';
  overrides.maxContentWidth = tuners.density > 0.6 ? '1400px' :
                              tuners.density < 0.4 ? '1000px' : '1200px';

  // Motion
  overrides.pathDrawEnabled = tuners.motion > 0.3;
  overrides.cardExpansionEnabled = tuners.motion > 0.4;
  overrides.hoverGlowEnabled = tuners.motion > 0.5;

  // Narrative
  overrides.sectionGapMultiplier = 0.7 + tuners.narrative * 0.6; // 0.7-1.3
  overrides.heroHeightMultiplier = 0.8 + tuners.narrative * 0.4; // 0.8-1.2
  overrides.ribbonProminence = tuners.narrative < 0.3 ? 'subtle' :
                               tuners.narrative > 0.7 ? 'prominent' : 'normal';

  return overrides;
}

/**
 * Generate human-readable description of tuning
 */
export function generateTunerDescription(tuners: AppliedTuners): string {
  const parts: string[] = [];

  // Abstraction
  if (tuners.abstraction > 0.7) parts.push('highly abstract');
  else if (tuners.abstraction < 0.3) parts.push('concrete');

  // Density
  if (tuners.density > 0.7) parts.push('dense');
  else if (tuners.density < 0.3) parts.push('spacious');

  // Motion
  if (tuners.motion > 0.7) parts.push('animated');
  else if (tuners.motion < 0.3) parts.push('static');

  // Contrast
  if (tuners.contrast > 0.7) parts.push('high-contrast');
  else if (tuners.contrast < 0.3) parts.push('low-contrast');

  // Narrative
  if (tuners.narrative > 0.7) parts.push('narrative-focused');
  else if (tuners.narrative < 0.3) parts.push('compact');

  if (parts.length === 0) return 'balanced';
  return parts.join(', ');
}

/**
 * Apply tuners and return complete output
 */
export function applyTuners(input: Partial<TunerValues>): TunerOutput {
  const tuners = normalizeTuners(input);
  const cssOverrides = generateCSSOverrides(tuners);
  const recipeOverrides = generateRecipeOverrides(tuners);
  const description = generateTunerDescription(tuners);

  return {
    tuners,
    cssOverrides,
    recipeOverrides,
    description,
  };
}

// =============================================================================
// URL PARAMETER PARSING
// =============================================================================

/**
 * Parse tuner values from URL search params
 */
export function parseTunersFromURL(searchParams: URLSearchParams): Partial<TunerValues> {
  const result: Partial<TunerValues> = {};

  const parseFloat01 = (key: string): number | undefined => {
    const value = searchParams.get(key);
    if (value === null) return undefined;
    const num = parseFloat(value);
    if (isNaN(num)) return undefined;
    return Math.max(0, Math.min(1, num));
  };

  const abstraction = parseFloat01('abstraction');
  const density = parseFloat01('density');
  const motion = parseFloat01('motion');
  const contrast = parseFloat01('contrast');
  const narrative = parseFloat01('narrative');

  if (abstraction !== undefined) result.abstraction = abstraction;
  if (density !== undefined) result.density = density;
  if (motion !== undefined) result.motion = motion;
  if (contrast !== undefined) result.contrast = contrast;
  if (narrative !== undefined) result.narrative = narrative;

  return result;
}

/**
 * Serialize tuner values to URL search params
 */
export function tunersToURLParams(tuners: Partial<TunerValues>): URLSearchParams {
  const params = new URLSearchParams();

  if (tuners.abstraction !== undefined) params.set('abstraction', tuners.abstraction.toFixed(1));
  if (tuners.density !== undefined) params.set('density', tuners.density.toFixed(1));
  if (tuners.motion !== undefined) params.set('motion', tuners.motion.toFixed(1));
  if (tuners.contrast !== undefined) params.set('contrast', tuners.contrast.toFixed(1));
  if (tuners.narrative !== undefined) params.set('narrative', tuners.narrative.toFixed(1));

  return params;
}

// =============================================================================
// DOM INTEGRATION
// =============================================================================

/**
 * Apply CSS variable overrides to document
 */
export function applyCSSOverridesToDocument(overrides: TunerCSSOverrides): void {
  if (typeof document === 'undefined') return;
  const root = document.documentElement;
  for (const [key, value] of Object.entries(overrides)) {
    root.style.setProperty(key, value);
  }
}

/**
 * Remove CSS variable overrides from document
 */
export function removeCSSOverridesFromDocument(overrides: TunerCSSOverrides): void {
  if (typeof document === 'undefined') return;
  const root = document.documentElement;
  for (const key of Object.keys(overrides)) {
    root.style.removeProperty(key);
  }
}

// =============================================================================
// EXPORTS
// =============================================================================

export default {
  DEFAULT_TUNERS,
  TUNER_BOUNDS,
  applyTuners,
  parseTunersFromURL,
  tunersToURLParams,
};
